## 问题定义

在分布式系统中，一致性(consensus，早期叫 agreement)问题是指对于系统中的多个服务节点，给定一系列操作，在一致性协议保障下，试图使得它们的处理结果达成一致。

如果系统能实现一致性，对外就可以呈现是一个功能正常的，但性能和稳定性都要好很多的“虚处理节点”。

*需要注意，这个一致性并不代表正确与否，所有节点都达成失败状态也是一种一致性。*

举个例子，某影视公司旗下有西单和中关村的两个电影院，都出售某电影票，加起来不能超过一万张。那么，顾客到达西单电影院买票的时候，售票员该怎么决策是否卖票呢？一个很直觉的思路就是每次卖票前打电话给中关村，确认下票数。

这个问题在人类世界中，看起来似乎没那么难，你看，英国人不是刚靠 [投票](http://www.bbc.com/news/politics/eu_referendum/results) 达成了“某种一致性”吗？

但是在实际的计算机系统（计算机系统往往比人类世界要脆弱的多）中，存在如下的问题：

* 节点之间的网络通讯是不可靠的，包括任意延迟和内容故障；
* 节点的处理可能是错误的，甚至节点自身随时可能宕机；
* 同步调用会让系统变得不具备可扩展性。

规范的说，一个分布式的一致性算法应该满足：

* 可终止性（Termination）：一致性的结果在有限时间内能完成；
* 一致性（Consensus）：不同节点最终决策的结果应该相同；
* 合法性（Validity）：决策的结果必须是其它进程提出的提案。

### 带约束的一致性

做过分布式系统的读者应该能意识到，绝对理想的一致性很难达成。除非不发生任何故障，所有节点之间的通信无需任何时间，这个时候其实就等价于一台机器了。实际上，越强的一致性要求往往意味着越弱的实践性能。

很多时候，人们发现对一致性可以适当放宽一些要求，在一定约束下实现一致性，从弱到强分别有如下几种：

* 顺序一致性（[Sequential Consistency](https://en.wikipedia.org/wiki/Sequential_consistency)）：Leslie Lamport 1978 年提出，是一种较弱的约束，保证所有进程自身执行的实际结果跟指定的指令顺序一致。例如，某进程先执行 A，后执行 B，则实际得到的结果就应该为 `A, B`，而不能是 `B, A`，所有其它进程也应该看到这个顺序，但不保证什么时候能看到。顺序一致性实际上只限制了各进程内指令的偏序关系，不在进程间进行排序。
* 线性一致性（[Linearizability Consistency](https://en.wikipedia.org/wiki/Linearizability)）：Maurice P. Herlihy 与 Jeannette M. Wing 在 1990 年共同提出，在顺序一致性前提下加强了进程间的操作排序，形成唯一的全局顺序（系统等价于是顺序执行，所有进程看到的所有操作的序列顺序都一致），是很强的原子性保证。但是很难实现，基本上要么依赖于全局的时钟或锁（原子钟是个简单粗暴但有效的主意），要么性能比较差。


### 一致性的理论界限

搞学术的人都喜欢对问题先确定一个界限，那么，这个问题的最坏界限在哪里呢？很不幸，一般情况下，分布式系统的一致性问题无解。

当节点之间的通信网络自身不可靠情况下，很显然，无法确保实现一致性。但好在，一个设计得当的网络可以在大概率上实现可靠的通信。

然而，**即便在网络通信可靠情况下，一个可扩展的分布式系统的一致性问题的下限是无解。**

这个结论，被称为 `FLP 不可能性` 原理。



